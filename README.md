# TSCrunch

TSCrunch is an optimal, byte-aligned, LZ+RLE hybrid encoder, designed to maximize decoding speed on NMOS 6502 and derived CPUs, while keeping decent compression performance (for a bytecruncher, that is).
TSCrunch was designed as the default asset cruncher for the upcoming game A Pig Quest, and, as such, it's optimized for in-memory level compression, but at as of version 1.0 it can also create SFX executables for off-line prg crunching.

Requirements
============

TSCrunch requires python 3.x with scipy library installed, or a windows x64 machine(A pre-compiled windows x64 command line executable is also provided). The memory decruncher requires Kick Assembler, but it should be quite easy to port it to your assembler of choice.

Usage
=====

	tscrunch [option] infile outfile

Crunching examples:

	tscrunch -x $0820 game.prg crunched.prg
	
Crunches the file game.prg and generates a self executable crunched.prg, using $0820 as post-decrunch jmp address

	tscrunch -p game.prg crunched.bin

Mem-crunches the file game.prg, stripping the 2-byte header and generates a binary file crunched.bin

	tscrunch data.bin crunched.bin

Mem-crunches the file data.bin and generates a binary file crunched.bin

Please refer to the inline help (tscrunch -h) for a detailed description of the different crunching options.
Note that with the exception of self executables and inplace, all the files generated by TSCrunch are headless binaries, that is they don't come with a 2 byte loader offset.

Decrunching files from code
===========================

For memory decrunching, please #include decrunch.asm and include the crunched binaries in your code, then use the macro TS_DECRUNCH, as explained by the following code fragment 

		.pc = $1000 "test"
		//decrunches data to $4000
		:TS_DECRUNCH(compressed_data,$4000) 
		jmp *

		.align $100
		#include "decrunch.asm"
		
		compressed_data:
		.import binary "data.bin"
		

For inplace decrunching, please #define INPLACE before including the decruncher code, as explained by the following code fragment

		#define INPLACE

		.pc = $1000 "test"
		//decrunches data inplace
		:TS_DECRUNCH(compressed_data) 
		jmp *

		.align $100
		#include "decrunch.asm"
		
		.pc = LoadAddress //as provided by the cruncher
		compressed_data:
		.import c64 "data.bin"


Performance
===========

TSCrunch is designed for ultra-fast decrunching while keeping a decent compression ratio. Being a byte-cruncher, it falls short of popular bit-crunchers, such as exomizer or B2, when comparing compression efficiency, but it is usually much faster at decoding. Furthermore, you can expect a 20% to 40% speed bump compared to popular byte-crunchers with similar compression efficiency.
The following benchmark compares TSCrunch performance with those of a fast byte-cruncher, TinyCrunch, and a two fast bit-crunchers, B2 and dali, on a real-case compression scenarios: Chopper Command, from the same author.

![image](https://user-images.githubusercontent.com/52791690/157232813-41efc81c-55c2-476a-8d83-fb886b7dc722.png)

Future development
==================

Block-loading management for integration in disk loaders.

Improve compression implementing repeated matches


