TSCrunch V1.0

by Antonio Savona

February 2022


About
=====

TSCrunch is an optimal, byte-aligned, LZ+RLE hybrid encoder, designed to maximize decoding speed on NMOS 6502 and derived CPUs, while keeping decent compression performance (for a bytecruncher, that is).
TSCrunch was designed as the default asset cruncher for the upcoming game A Pig Quest, and, as such, it's optimized for in-memory level compression, but at as of version 1.0 it can also create SFX executables for off-line prg crunching.

Requirements
============

TSCrunch requires python 3.x with scipy library installed, or a windows x64 machine(A pre-compiled windows x64 command line executable is also provided). The memory decruncher requires Kick Assembler, but it should be quite easy to port it to your assembler of choice.

Usage
=====

tscrunch [option] infile outfile

Crunching examples:

tscrunch -x $0820 game.prg crunched.prg
Crunches the file game.prg and generates a self executable crunched.prg, using $0820 as post-decrunch jmp address

tscrunch -p game.prg crunched.bin
Mem-crunches the file game.prg, stripping the 2-byte header and generates a binary file crunched.bin

tscrunch data.bin crunched.bin
Mem-crunches the file data.bin and generates a binary file crunched.bin

Please refer to the inline help (tscrunch -h) for a detailed description of the different crunching option.
Note that with the exception of self executables, all the files generated by tscrunch are headless binaries, that is they don't come with a 2 byte loader offset.

For memory decrunching, please #include decrunch.asm and include the crunched binaries in your software, then use the macro TS_DECRUNCH, as explained by the following code fragment 

		.pc = $1000 "test"
		//decrunches data to $4000
		:TS_DECRUNCH(compressed_data,$4000) 
		jmp *

		.align $100
		#include "decrunch.asm"
		
		compressed_data:
		.import binary "data.bin"
		

Performance
===========

TSCrunch is designed for ultra-fast decrunching while keeping a decent compression ratio. Being a byte-cruncher, it falls short of popular bit-crunchers, such as exomizer or B2, when comparing compression efficiency, but it is usually much faster at decoding. Furthermore, you can expect a 20% to 40% speed bump compared to popular byte-crunchers with similar compression efficiency.
The following benchmark compares TSCrunch performance with those of a fast byte-cruncher, TinyCrunch, and a fast bit-cruncher, B2, on two real-case compression scenarios: Chopper Command and Frostbite, from the same author.


Chopper Command - Raw encoding	 - game prg		
			
				Tscrunch 1.0	TinyCrunch 1.2	B2
Size			46913			46913			46913
Crunched size	13321			15419			11181
% of original	28.40%			32.87%			23.83%
Decrunch cycles	799826			1133039			1694585
Cycles per byte	17.0491335		24.15191951		36.12186388

			
Frostbite - Raw encoding - game prg			
			
				Tscrunch 1.0	TinyCrunch 1.2	B2
Size			61185			61185			61185
Crunched size	21329			22931			17759
% of original	34.86%			37.48%			29.03%
Decrunch cycles	1176826			1507239			2475450
Cycles per byte	19.2338972		24.63412601		40.4584457



Future development
==================

-Block-loading management for integration in disk loaders
-Add in-place decrunching
